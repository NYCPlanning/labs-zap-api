import {
  HttpException,
  HttpStatus,
  Injectable,
} from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import * as moment from 'moment';
import { ConfigService } from '../config/config.service';
import { ContactService } from '../contact/contact.service';

/**
 * This class describes the central auth service. Two public methods are available.
 * This service is responsible for verifying and generating new tokens.
 *
 * @class      AuthService (name)
 */
@Injectable()
export class AuthService {
  // required env variables
  CRM_SIGNING_SECRET = '';
  NYCID_CONSOLE_PASSWORD = '';

  // development environment features
  SKIP_AUTH = false;
  CRM_IMPOSTER_ID = '';

  constructor(
    private readonly config: ConfigService,
    private readonly contactService: ContactService,
  ) {
    this.CRM_SIGNING_SECRET = this.config.get('CRM_SIGNING_SECRET');
    this.NYCID_CONSOLE_PASSWORD = this.config.get('NYCID_CONSOLE_PASSWORD');

    this.SKIP_AUTH = this.config.get('SKIP_AUTH');
    this.CRM_IMPOSTER_ID = this.config.get('CRM_IMPOSTER_ID');
  }

  /**
   * Verifies an NYCIDToken. Then, looks up a contact associated with
   * that NYC.ID token using provided email. Lastly, signs a new token
   * which includes the contact ID for that.
   *
   * @param      {<type>}  NYCIDToken  The nycid token
   */
  public async generateNewToken(NYCIDToken: string): Promise<string> {
    const { CRM_IMPOSTER_ID } = this;

    if (this.SKIP_AUTH) {
      console.log('Warning! SKIP_AUTH is set to true. Your app is unsecured!');

      return this.signNewToken(CRM_IMPOSTER_ID);
    }

    const { mail, exp } = this.verifyNYCIDToken(NYCIDToken);
    const { contactid } = await this.lookupContact(mail);

    return this.signNewToken(contactid, exp);
  }

  /**
   * Validates the current signed JWT generated by ZAP API.
   *
   * @param      {string}  token   The token
   */
  public validateCurrentToken(token: string) {
    const { CRM_IMPOSTER_ID } = this;

    if (this.SKIP_AUTH) {
      console.log('Warning! SKIP_AUTH is set to true. Your app is unsecured!');

      return this.signNewToken(CRM_IMPOSTER_ID);
    }

    return this.verifyCRMToken(token);
  }

  /**
   * Lookup a contact entity by email or, if present, a contact ID.
   * Throws an unauthorized error if a contact is not found
   *
   * @param      {string}  mail    An email account to be found in CRM
   */
  private async lookupContact(mail: string) {
    const { CRM_IMPOSTER_ID } = this;

    try {
      // prefer CRM_IMPOSTER_ID if it exists
      return this.contactService.findOne(CRM_IMPOSTER_ID || { emailaddress1: mail });
    } catch (e) {
      throw new HttpException(e, HttpStatus.UNAUTHORIZED);
    }
  }

  /**
   * Verifies a JWT with the NYCID signature. Returns the token object.
   *
   * @param      {string}  token   The token
   * @return     {object}     { mail: 'string', exp: 'string' }
   */
  private verifyNYCIDToken(token): any {
    const { NYCID_CONSOLE_PASSWORD } = this;

    return this.verifyToken(token, NYCID_CONSOLE_PASSWORD);
  }

  /**
   * Verifies a JWT with the CRM signing secret. Returns a token object.
   *
   * @param      {string}  token   The token
   * @return     {any}     { mail: 'string', exp: 'string' }
   */
  private verifyCRMToken(token): any {
    const { CRM_SIGNING_SECRET } = this;

    return this.verifyToken(token, CRM_SIGNING_SECRET);
  }

  /**
   * Generates a new ZAP API token, including the contact id
   *
   * @param      {string}  contactid  The CRM contactid
   * @param      {string}  exp        A string coercable to a Date
   */
  private signNewToken(
    contactid: string,
    exp: number = moment().add(1, 'days').unix(),
  ): string {
    const { CRM_SIGNING_SECRET } = this;

    return jwt.sign({ contactid, exp }, CRM_SIGNING_SECRET);
  }

  /**
   * Verifies a token given a JWT and a secret. Throws an error
   * if there is a problem verifying.
   *
   * @param      {string}  token   The token
   * @param      {string}  secret  The secret
   * @return     {string|object}  { Returns an object or string depending on the JWT }
   */
  private verifyToken(token, secret): string | {} {
    try {
      return jwt.verify(token, secret);
    } catch (e) {
      throw new HttpException(e, HttpStatus.UNAUTHORIZED);
    }
  }
}
